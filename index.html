<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Pose Detection - Pro Switch</title>
  <style>
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; background: black; overflow: hidden; }
    video, canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }
    .mirror { transform: scaleX(-1); -webkit-transform: scaleX(-1); }
    canvas { pointer-events: none; z-index: 5; }
    #tip { position: absolute; top: 12px; left: 12px; color: #4ec9b0; font-size: 14px; font-family: monospace; z-index: 10; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; }
    #switchBtn { position: absolute; bottom: 40px; right: 30px; width: 60px; height: 60px; background: rgba(255,255,255,0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; z-index: 20; border: 2px solid #fff; color: white; font-size: 30px; cursor: pointer; backdrop-filter: blur(4px); -webkit-tap-highlight-color: transparent; }
  </style>
</head>
<body>
  <div id="tip">System Initializing...</div>
  <div id="switchBtn">ğŸ”„</div>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <script type="module">
    import { PoseLandmarker, FilesetResolver } from "/mediapipe/tasks-vision/vision_bundle.js";

    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const tip = document.getElementById("tip");
    const switchBtn = document.getElementById("switchBtn");

    let poseLandmarker = null;
    let running = false;
    let currentFacingMode = "user"; 

    // --- æ ¸å¿ƒä¿®å¤ï¼šæ›´å¥å£®çš„æ‘„åƒå¤´å¯åŠ¨é€»è¾‘ ---
    async function startCamera() {
      running = false; 
      tip.textContent = "Switching Camera...";

      // 1. å½»åº•åœæ­¢å¹¶ç§»é™¤æ‰€æœ‰è½¨é“
      if (video.srcObject) {
        const tracks = video.srcObject.getTracks();
        tracks.forEach(track => {
          track.stop();
          console.log("Stopped track:", track.label);
        });
        video.srcObject = null;
      }

      // 2. å»¶è¿Ÿä¸€å°ä¼šå„¿ï¼Œç»™ç³»ç»Ÿé‡Šæ”¾ç¡¬ä»¶çš„æ—¶é—´ï¼ˆæŸäº›å®‰å“ Webview å¿…é¡»è¿™æ ·åšï¼‰
      await new Promise(resolve => setTimeout(resolve, 300));

      const constraints = [
        { video: { facingMode: { exact: currentFacingMode }, width: { ideal: 1280 }, height: { ideal: 720 } } },
        { video: { facingMode: currentFacingMode, width: { ideal: 640 }, height: { ideal: 480 } } },
        { video: true } // æœ€ç»ˆä¿åº•
      ];

      let lastError;
      for (const constraint of constraints) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia(constraint);
          video.srcObject = stream;
          
          // 3. å¤„ç†é•œåƒæ˜¾ç¤º
          if (currentFacingMode === "user") {
            video.classList.add("mirror");
            canvas.classList.add("mirror");
          } else {
            video.classList.remove("mirror");
            canvas.classList.remove("mirror");
          }

          await new Promise(r => video.onloadedmetadata = r);
          await video.play();

          // 4. åŒæ­¥ Canvas ä¸è§†é¢‘ç‰©ç†åˆ†è¾¨ç‡
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          
          running = true;
          tip.textContent = `Active: ${currentFacingMode}`;
          return; // æˆåŠŸåé€€å‡ºå¾ªç¯
        } catch (e) {
          lastError = e;
          console.warn("Constraint failed, trying next...", e);
        }
      }
      
      tip.textContent = "Error: " + lastError.message;
    }

    async function initPose() {
      const vision = await FilesetResolver.forVisionTasks("/mediapipe/tasks-vision/wasm");
      poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "/mediapipe/model/pose_landmarker_lite.task", delegate: "GPU" },
        runningMode: "VIDEO",
        numPoses: 1
      });
      tip.textContent = "AI Ready";
      requestAnimationFrame(loop);
    }

    function loop(ts) {
      if (running && poseLandmarker) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const result = poseLandmarker.detectForVideo(video, ts);
        if (result.landmarks && result.landmarks[0]) {
          drawPose(result.landmarks[0]);
        }
      }
      requestAnimationFrame(loop);
    }

    /* ---------------- ç»˜å›¾é€»è¾‘ (åŒå‰) ---------------- */
    function toCanvas(p) { return { x: p.x * canvas.width, y: p.y * canvas.height }; }
    function calcAngle(a, b, c) {
      const ab = { x: a.x - b.x, y: a.y - b.y }, cb = { x: c.x - b.x, y: c.y - b.y };
      const dot = ab.x * cb.x + ab.y * cb.y;
      return Math.acos(dot / (Math.hypot(ab.x, ab.y) * Math.hypot(cb.x, cb.y))) * 180 / Math.PI;
    }

    function drawPose(lm) {
      ctx.save();
      ctx.strokeStyle = "#4ec9b0";
      ctx.fillStyle = "#ffffff";
      ctx.lineWidth = 4;
      const bones = [[11,13],[13,15],[12,14],[14,16],[23,25],[25,27],[24,26],[26,28],[11,12],[23,24],[11,23],[12,24]];
      bones.forEach(([a,b]) => {
        const p1 = toCanvas(lm[a]), p2 = toCanvas(lm[b]);
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
      });
      lm.forEach((p, i) => { if (i >= 11) {
        const cp = toCanvas(p);
        ctx.beginPath(); ctx.arc(cp.x, cp.y, 4, 0, Math.PI * 2); ctx.fill();
      }});
      [[11,13,15], [12,14,16], [23,25,27], [24,26,28]].forEach(([a,b,c]) => {
        const angle = Math.round(calcAngle(lm[a], lm[b], lm[c]));
        const p = toCanvas(lm[b]);
        ctx.font = "bold 16px monospace";
        ctx.fillStyle = "#4ec9b0";
        ctx.fillText(`${angle}Â°`, p.x + 10, p.y - 10);
      });
      ctx.restore();
    }

    // åˆ‡æ¢æŒ‰é’®ç›‘å¬
    switchBtn.addEventListener('click', () => {
      currentFacingMode = (currentFacingMode === "user") ? "environment" : "user";
      startCamera();
    });

    startCamera();
    initPose();

    /* --- åŸæœ‰å½•åˆ¶æ¥å£ä¿æŒä¸å˜ --- */
    window.startRecord = async function(){ /* ...åŒå‰... */ };
    window.stopAndUpload = async function(url, token){ /* ...åŒå‰... */ };
  </script>
</body>
</html>