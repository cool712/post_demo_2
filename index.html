<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Pose Detection - Switch Camera</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: black;
      overflow: hidden;
    }

    video, canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* é»˜è®¤å‰ç½®é•œåƒï¼Œåç½®é€»è¾‘åœ¨ JS ä¸­åŠ¨æ€æ§åˆ¶ */
    .mirror {
      transform: scaleX(-1);
      -webkit-transform: scaleX(-1);
    }

    canvas {
      pointer-events: none;
      z-index: 5;
    }

    #tip {
      position: absolute;
      top: 12px;
      left: 12px;
      color: #4ec9b0;
      font-size: 14px;
      font-family: monospace;
      z-index: 10;
      background: rgba(0,0,0,0.5);
      padding: 4px 8px;
      border-radius: 4px;
    }

    /* åˆ‡æ¢æ‘„åƒå¤´æŒ‰é’®æ ·å¼ */
    #switchBtn {
      position: absolute;
      bottom: 30px;
      right: 30px;
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      border: 2px solid white;
      color: white;
      cursor: pointer;
      font-size: 24px;
      user-select: none;
    }
  </style>
</head>

<body>
  <div id="tip">Initializingâ€¦</div>
  <div id="switchBtn">ğŸ”„</div>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <script type="module">
    /* ---------------- 1. å½•åˆ¶é€»è¾‘ ---------------- */
    let mediaRecorder;
    let recordedChunks = [];
    let startTime;

    window.startRecord = async function () {
      if (!video.srcObject) return;
      recordedChunks = [];
      const mimeType = MediaRecorder.isTypeSupported("video/mp4") ? "video/mp4" : "video/webm;codecs=vp8";
      mediaRecorder = new MediaRecorder(video.srcObject, { mimeType });
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
      startTime = Date.now();
      mediaRecorder.start();
    };

    window.stopAndUpload = async function (uploadUrl, token) {
      if (!mediaRecorder) return;
      mediaRecorder.onstop = async () => {
        const duration = (Date.now() - startTime) / 1000;
        const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
        const formData = new FormData();
        const ext = mediaRecorder.mimeType.includes("mp4") ? "mp4" : "webm";
        formData.append("file", blob, `record_${Date.now()}.${ext}`);
        formData.append("duration", duration);
        try {
          const response = await fetch(uploadUrl, { method: "POST", body: formData });
          window.flutter_inappwebview.callHandler("onUploadComplete", { success: response.ok, status: response.status });
        } catch (err) {
          window.flutter_inappwebview.callHandler("onUploadComplete", { success: false });
        }
      };
      mediaRecorder.stop();
    };

    /* ---------------- 2. æ‘„åƒå¤´ä¸ AI é€»è¾‘ ---------------- */
    import { PoseLandmarker, FilesetResolver } from "/mediapipe/tasks-vision/vision_bundle.js";

    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const tip = document.getElementById("tip");
    const switchBtn = document.getElementById("switchBtn");

    let poseLandmarker = null;
    let running = false;
    let currentFacingMode = "user"; // åˆå§‹ä½¿ç”¨å‰ç½®

    // åˆ‡æ¢æŒ‰é’®äº‹ä»¶
    switchBtn.onclick = () => {
      currentFacingMode = currentFacingMode === "user" ? "environment" : "user";
      startCamera();
    };

    async function startCamera() {
      tip.textContent = "Switching camera...";
      
      // åœæ­¢æ—§è½¨é“ï¼Œé˜²æ­¢æ‘„åƒå¤´å ç”¨é”™è¯¯
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { 
            facingMode: currentFacingMode, 
            width: { ideal: 1280 }, 
            height: { ideal: 720 } 
          },
          audio: false
        });

        video.srcObject = stream;

        // æ ¹æ®æ‘„åƒå¤´æ¨¡å¼å†³å®šæ˜¯å¦é•œåƒ
        if (currentFacingMode === "user") {
          video.classList.add("mirror");
          canvas.classList.add("mirror");
        } else {
          video.classList.remove("mirror");
          canvas.classList.remove("mirror");
        }

        await new Promise(r => video.onloadedmetadata = r);
        await video.play();

        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        running = true;
        tip.textContent = `Camera: ${currentFacingMode}`;
      } catch (err) {
        tip.textContent = "Camera error: " + err.message;
      }
    }

    async function initPose() {
      const vision = await FilesetResolver.forVisionTasks("/mediapipe/tasks-vision/wasm");
      poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "/mediapipe/model/pose_landmarker_lite.task", delegate: "GPU" },
        runningMode: "VIDEO",
        numPoses: 1
      });
      tip.textContent = "Ready";
    }

    /* ---------------- 3. AI å¾ªç¯ ---------------- */
    function loop(ts) {
      requestAnimationFrame(loop);
      if (!running || !poseLandmarker) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const result = poseLandmarker.detectForVideo(video, ts);
      
      if (result.landmarks && result.landmarks.length > 0) {
        drawPose(result.landmarks[0]);
      }
    }

    function toCanvas(p) {
      return { x: p.x * canvas.width, y: p.y * canvas.height };
    }

    function calcAngle(a, b, c) {
      const ab = { x: a.x - b.x, y: a.y - b.y }, cb = { x: c.x - b.x, y: c.y - b.y };
      const dot = ab.x * cb.x + ab.y * cb.y;
      return Math.acos(dot / (Math.hypot(ab.x, ab.y) * Math.hypot(cb.x, cb.y))) * 180 / Math.PI;
    }

    function drawPose(lm) {
      ctx.save();
      ctx.strokeStyle = "#4ec9b0";
      ctx.fillStyle = "#ffffff";
      ctx.lineWidth = 3;
      const bones = [[11,13],[13,15],[12,14],[14,16],[23,25],[25,27],[24,26],[26,28],[11,12],[23,24],[11,23],[12,24]];
      bones.forEach(([a,b]) => {
        const p1 = toCanvas(lm[a]), p2 = toCanvas(lm[b]);
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
      });
      lm.forEach((p, i) => {
        if (i < 11) return; 
        const cp = toCanvas(p);
        ctx.beginPath(); ctx.arc(cp.x, cp.y, 2, 0, Math.PI * 2); ctx.fill();
      });
      [ [11,13,15], [12,14,16], [23,25,27], [24,26,28] ].forEach(([a,b,c]) => {
        const angle = Math.round(calcAngle(lm[a], lm[b], lm[c]));
        const p = toCanvas(lm[b]);
        ctx.font = "bold 14px monospace";
        ctx.fillText(`${angle}Â°`, p.x + 8, p.y - 8);
      });
      ctx.restore();
    }

    startCamera();
    initPose();
    requestAnimationFrame(loop);
  </script>
</body>
</html>